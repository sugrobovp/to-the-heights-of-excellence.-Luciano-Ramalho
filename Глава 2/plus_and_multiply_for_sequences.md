# Использование + и * для последовательностей

### Пример 1. Конкатенация последовательностей
``` python
>>> l = [1, 2, 3]
>>> l * 5
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
>>> 5 * 'abcd'
'abcdabcdabcdabcdabcd'
```
Нужно заметить, что операторы + и * всегда создают новый объект, не изменяя свои операнды.

### Пример 5. Неожиданный результат при применении * к последовательности, содержащей изменяемые элементы.
``` python
>>> my_list = [[]] * 3
>>> my_list
[[], [], []]
```

### Пример 6а. Построение списка списков .
``` python
>>> board = [['_'] * 3 for i in range(3)]
>>> board
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
>>> board[1][2] = 'X'
>>> board
[['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]
```
### Пример 6б. Построение списка списков (бесполезный вариант).
``` python
>>> weird_board = [['_'] * 3] * 3
>>> weird_board
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
>>> weird_board[1][2] = 'O'
>>> weird_board
[['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']]
```
Проблема в том, что этот список содержит три ссылки на один и тот же список. Что и видно при изменении. То есть код в примере 6б эквивалентен следующему:
``` python
row = ['_'] * 3
board = []
for i in range(3):
board.append(row)
```
Мы добавляем один и тот же объект row в список board 3 раза. С другой стороны код в примере 6а эквивалентен следующему:
``` python
>>> board = []
>>> for i in range(3):
... row = ['_'] * 3
... board.append(row)
...
>>> board
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
>>> board[2][0] = 'X'
>>> board
[['_', '_', '_'], ['_', '_', '_'], ['X', '_', '_']]
```
На каждой итерации строится новый список row, который добавляется в список board.

### Составное присваивание последовательностей
За оператором += стоит метод __iadd__ (in-place addition - сложение на месте). Если метод __iadd__ не реализован, то вызывается __add__. Рассмотрим простое выражение:
``` python
>>> a += b
```
Если оператор a реализует __iadd__, то результат будет изменен на месте. Например это происходит в случае изменяемых последовательностей (list, array.array). Результат будет такой же, как и при вызове a.extend(b). Если же a не реализует __iadd__, то в выражении a += b сначала вычисляется a + b, а потом получившийся новый объект связывается с переменной a. То есть id меняется в зависимости от того, реализован ли метод __iadd__.

То же самое применимо и к методу __imul__ для оператора *=.

### Пример применения *= к изменяемым и неизменяемым последовательностям:
``` python
>>> l = [1, 2, 3]
>>> id(l)
4311953800
>>> l *= 2
>>> l
[1, 2, 3, 1, 2, 3]
>>> id(l)
4311953800
>>> t = (1, 2, 3)
>>> id(t)
4312681568
>>> t *= 2
>>> id(t)
4301348296
```
У списка реализован метод __imul__. То есть после умножения список является тем же самым объектом. Для кортежа же в результате умножения был создан новый объект. Таким образом кратная конкатенация неизменяемых последовательностей неэффективна, так как мы будем копировать эту последовательность, чтобы создать новую.
